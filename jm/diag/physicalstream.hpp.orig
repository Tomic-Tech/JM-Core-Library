#ifndef __JM_DIAG_DEVICE_STREAM_HPP__
#define __JM_DIAG_DEVICE_STREAM_HPP__

#ifdef _MSC_VER
#pragma once
#endif

#include <boost/asio.hpp>
#include <boost/array.hpp>
#include <boost/bind.hpp>
#include <boost/thread.hpp>
#include <jm/diag/stream.hpp>

namespace JM
{
namespace Diag
{
template<typename PhysicalType>
class PhysicalStream : public boost::noncopyable
{
public:
    PhysicalStream(Stream &toCommbox,
                   Stream &fromCommbox,
                   boost::mutex &mutex,
                   boost::condition_variable &cond)
        : _io()
        , _physical(_io)
        , _writeTime(_io, boost::posix_time::milliseconds(1))
        , _readTime(_io, boost::posix_time::milliseconds(1))
        , _writing(true)
        , _reading(true)
        , _toCommbox(toCommbox)
        , _fromCommbox(fromCommbox)
        , _mutex(mutex)
        , _cond(cond)
        , _writeThread(boost::bind(&PhysicalStream::writeToCommbox, this))
        , _readThread(boost::bind(&PhysicalStream::readFromCommbox, this))
    {
    }

    PhysicalType& physical()
    {
        return _physical;
    }
private:

    void writeToCommbox()
    {
        boost::array<boost::uint8_t, 255> cache;
        boost::system::error_code ec;
        _writing = true;
        while (_writing)
        {
            std::size_t avail = _toCommbox.bytesAvailable();
            if (avail)
            {
                boost::this_thread.yield();
                continue;
            }
            _toCommbox.read(boost::asio::mutable_buffer(cache.data(), avail));
            boost::asio::async_write(_physical, boost::asio::const_buffers_1(cache.data(), avail), ec);
            _writeTime.expires_from_now(boost::posix_time::milliseconds(100), ec);
            _writeTime.wait(ec);
            _io.run(ec);
        }
    }

    void readFromCommbox()
    {
                boost::array<boost::uint8_t, 255> cache;
        boost::system::error_code ec;
        _writing = true;
    }

    void startReadFromCommbox()
    {
        // start an asynchronous read and call readComplete when it completes or fails
        _physical.async_read_some(boost::asio::mutable_buffers_1(&fromCommboxBuff, 1),
                                  boost::bind(&PhysicalStream::readComplete,
                                              this,
                                              boost::asio::placeholders::error,
                                              boost::asio::placeholders::bytes_transferred));

    }

    void readComplete(const boost::system::error_code &ec,
                      std::size_t bytes_transferred)
    {
        // the asynchronous read operation has now completed or failed and returned an error
        if (!ec)
        {
            boost::system::error_code error;
            // read complete, so process the data
            _fromCommbox.write(boost::asio::const_buffer(&fromCommboxBuff, 1), error);
            _cond.notify_one();
        }
        startReadFromCommbox(); // start waiting for another asynchronous read again.
    }
private:
    boost::asio::io_service _io;
    boost::asio::deadline_timer _writeTime;
    boost::asio::deadline_timer _readTime;
    bool _writing;
    bool _reading;
    PhysicalType _physical;
    Stream &_toCommbox;
    Stream &_fromCommbox;
    boost::uint8_t fromCommboxBuff;
    boost::mutex &_mutex;
    boost::condition_variable &_cond;
    boost::thread _writeThread;
    boost::thread _readThread;
};

}
}

#endif