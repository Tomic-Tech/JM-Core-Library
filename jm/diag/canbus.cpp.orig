#include "canbus.hpp"
#include <jm/utils.hpp>

namespace JM
{
namespace Diag
{
Canbus::Canbus()
{
    _flowControl[0] = 0x30;
    _flowControl[1] = 0x00;
    _flowControl[2] = 0x00;
    _flowControl[3] = 0x00;
    _flowControl[4] = 0x00;
    _flowControl[5] = 0x00;
    _flowControl[6] = 0x00;
    _flowControl[7] = 0x00;
}

Canbus::~Canbus()
{

}

std::size_t Canbus::pack(const boost::uint8_t *src,
                         std::size_t srcLength,
                         boost::uint8_t *tar,
                         std::size_t tarMaxLength,
                         boost::system::error_code &ec)
{
    if (srcLength > 8 || srcLength <= 0)
    {
        ec = boost::asio::error::message_size;
        return 0;
    }

    if (_idMode == ID_MODE_STD)
    {
        tar[1] = HighByte(LowWord(_targetID));
        tar[2] = LowByte(LowWord(_targetID));
        if (_frameType == FRAME_TYPE_DATA)
        {
            tar[0] = LowByte(srcLength | ID_MODE_STD | FRAME_TYPE_DATA);
        }
        else
        {
            tar[0] = LowByte(srcLength | ID_MODE_STD | FRAME_TYPE_REMOTE);
        }
        memcpy(tar + 3, src, srcLength);
        return srcLength + 3;
    }
    if (_idMode == ID_MODE_EXT)
    {
        tar[1] = HighByte(HighWord(_targetID));
        tar[2] = LowByte(HighWord(_targetID));
        tar[3] = HighByte(LowWord(_targetID));
        tar[4] = LowByte(LowWord(_targetID));
        if (_frameType == FRAME_TYPE_DATA)
        {
            tar[0] = LowByte(srcLength | ID_MODE_EXT | FRAME_TYPE_DATA);
        }
        else
        {
            tar[0] = LowByte(srcLength | ID_MODE_EXT | FRAME_TYPE_REMOTE);
        }
        memcpy(tar + 5, src, srcLength);
        return srcLength + 5;
    }
    return 0;
}

std::size_t Canbus::unpack(const boost::uint8_t *src,
                           std::size_t srcLength,
                           boost::uint8_t *tar,
                           std::size_t tarMaxLength,
                           boost::system::error_code &ec)
{
    if (srcLength <= 0)
    {
        ec = boost::asio::error::message_size;
        return 0;
    }

    std::size_t length = 0;

    boost::uint32_t mode = (src[0] & (ID_MODE_EXT | FRAME_TYPE_REMOTE));
    if (mode == (ID_MODE_STD | FRAME_TYPE_DATA))
    {
        length = src[0] & 0x0F;
        if (length != srcLength - 3)
        {
            ec = boost::asio::error::message_size;
            return 0;
        }

        memcpy(tar, src + 3, length);
    }

    if (mode == (ID_MODE_EXT | FRAME_TYPE_DATA))
    {
        length = src[0] & 0x0F;
        if (length != srcLength - 5)
        {
            ec = boost::asio::error::message_size;
            return 0;
        }

        memcpy(tar, src + 5, length);
    }
    return length;
}

void Canbus::setLines(boost::int32_t high, boost::int32_t low,
    boost::system::error_code &ec)
{
    _high = high;
    _low = low;

    ec = boost::system::error_code();
}

void Canbus::setFilter(const std::vector<boost::int32_t> &idVector,
    boost::system::error_code &ec)
{
    _idVector = idVector;
    ec = boost::system::error_code();
}

void Canbus::setOptions(boost::int32_t id, Baud baud, IDMode idMode, 
    FilterMask mask, FrameType frame, boost::system::error_code &ec)
{
    _baud = baud;
    _idMode = idMode;
    _filterMask = mask;
    _frameType = frame;
    _targetID = id;
    ec = boost::system::error_code();
}

}
}